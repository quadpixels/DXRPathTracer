//=================================================================================================
//
//  Modified to make use of DXR 1.1 (RayQuery). Loop flavor.
//
//  Generated by ChatGPT
//
//  DXR Path Tracer (RayQuery / Inline RT rewrite)
//  based on MJP DXRPathTracer RayTrace.hlsl
//
//=================================================================================================

#include <DescriptorTables.hlsl>
#include <Constants.hlsl>
#include <Quaternion.hlsl>
#include <BRDF.hlsl>
#include <RayTracing.hlsl>
#include <Sampling.hlsl>

#include "SharedTypes.h"
#include "AppSettings.hlsl"

struct RayTraceConstants
{
    row_major float4x4 InvViewProjection;

    float3 SunDirectionWS;
    float CosSunAngularRadius;
    float3 SunIrradiance;
    float SinSunAngularRadius;
    float3 SunRenderColor;
    uint Padding;
    float3 CameraPosWS;
    uint CurrSampleIdx;
    uint TotalNumPixels;

    uint VtxBufferIdx;
    uint VtxFloatBufferIdx;
    uint IdxBufferIdx;
    uint GeometryInfoBufferIdx;
    uint MaterialBufferIdx;
    uint SkyTextureIdx;
    uint NumLights;
};

struct LightConstants
{
    SpotLight Lights[MaxSpotLights];
    float4x4 ShadowMatrices[MaxSpotLights];
};

RaytracingAccelerationStructure Scene : register(t0, space200);
RWTexture2D<float4> RenderTarget : register(u0);

ConstantBuffer<RayTraceConstants> RayTraceCB : register(b0);
ConstantBuffer<LightConstants> LightCBuffer : register(b1);

SamplerState MeshSampler : register(s0);
SamplerState LinearSampler : register(s1);

static float2 SamplePoint(in uint pixelIdx, inout uint setIdx)
{
    const uint permutation = setIdx * RayTraceCB.TotalNumPixels + pixelIdx;
    setIdx += 1;
    return SampleCMJ2D(RayTraceCB.CurrSampleIdx, AppSettings.SqrtNumSamples, AppSettings.SqrtNumSamples, permutation);
}

// -------------------------------------------------------------------------------------------------
// Helpers that used to live in RT system-value intrinsics
// -------------------------------------------------------------------------------------------------

// Loops up the vertex data for the hit triangle and interpolates its attributes
MeshVertex GetHitSurface_RQ(in float2 bary2, in uint geometryIdx, in uint primitiveIdx)
{
    float3 barycentrics = float3(1.0f - bary2.x - bary2.y, bary2.x, bary2.y);

    StructuredBuffer<GeometryInfo> geoInfoBuffer = ResourceDescriptorHeap[RayTraceCB.GeometryInfoBufferIdx];
    const GeometryInfo geoInfo = geoInfoBuffer[geometryIdx];

    StructuredBuffer<MeshVertex> vtxBuffer = ResourceDescriptorHeap[RayTraceCB.VtxBufferIdx];
    Buffer<uint> idxBuffer = ResourceDescriptorHeap[RayTraceCB.IdxBufferIdx];

    // primitiveIdx is triangle index within the geometry
    const uint idx0 = idxBuffer[primitiveIdx * 3 + geoInfo.IdxOffset + 0];
    const uint idx1 = idxBuffer[primitiveIdx * 3 + geoInfo.IdxOffset + 1];
    const uint idx2 = idxBuffer[primitiveIdx * 3 + geoInfo.IdxOffset + 2];

    const MeshVertex vtx0 = vtxBuffer[idx0 + geoInfo.VtxOffset];
    const MeshVertex vtx1 = vtxBuffer[idx1 + geoInfo.VtxOffset];
    const MeshVertex vtx2 = vtxBuffer[idx2 + geoInfo.VtxOffset];

    return BarycentricLerp(vtx0, vtx1, vtx2, barycentrics);
}

// Gets the material assigned to a geometry in the acceleration structure
Material GetGeometryMaterial_RQ(in uint geometryIdx)
{
    StructuredBuffer<GeometryInfo> geoInfoBuffer = ResourceDescriptorHeap[RayTraceCB.GeometryInfoBufferIdx];
    const GeometryInfo geoInfo = geoInfoBuffer[geometryIdx];

    StructuredBuffer<Material> materialBuffer = ResourceDescriptorHeap[RayTraceCB.MaterialBufferIdx];
    return materialBuffer[geoInfo.MaterialIdx];
}

static bool PassAlphaTest_RQ(in uint geometryIdx, in uint primitiveIdx, in float2 bary2)
{
    const MeshVertex hitSurface = GetHitSurface_RQ(bary2, geometryIdx, primitiveIdx);
    const Material material = GetGeometryMaterial_RQ(geometryIdx);

    Texture2D opacityMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Opacity)];
    return opacityMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).x >= 0.35f;
}

// -------------------------------------------------------------------------------------------------
// Inline RT (RayQuery) wrappers
// -------------------------------------------------------------------------------------------------

struct HitInfoRQ
{
    bool hit;
    float t;
    uint geometryIdx;
    uint primitiveIdx;
    float2 bary;
};

static HitInfoRQ TraceClosestHitInline_Radiance(in RayDesc ray, in uint rayMask, in uint rayFlags)
{
    HitInfoRQ outHit;
    outHit.hit = false;
    outHit.t = 0.0f;
    outHit.geometryIdx = 0;
    outHit.primitiveIdx = 0;
    outHit.bary = 0.0.xx;

    // Note: RayQuery template flags can be 0; dynamic flags go in TraceRayInline().
    RayQuery < RAY_FLAG_NONE > q;
    q.TraceRayInline(Scene, rayFlags, rayMask, ray);

    while (q.Proceed())
    {
        // Only non-opaque triangle candidates return control for built-in triangles.
        // This is where we replicate AnyHit alpha-test.
        if (q.CandidateType() == CANDIDATE_NON_OPAQUE_TRIANGLE)
        {
            const uint geo = q.CandidateGeometryIndex();
            const uint prim = q.CandidatePrimitiveIndex();
            const float2 bary = q.CandidateTriangleBarycentrics();

            if (PassAlphaTest_RQ(geo, prim, bary))
            {
                q.CommitNonOpaqueTriangleHit();
            }
            // else: ignore (do not commit) => like IgnoreHit()
        }
    }

    if (q.CommittedStatus() == COMMITTED_TRIANGLE_HIT)
    {
        outHit.hit = true;
        outHit.t = q.CommittedRayT();
        outHit.geometryIdx = q.CommittedGeometryIndex();
        outHit.primitiveIdx = q.CommittedPrimitiveIndex();
        outHit.bary = q.CommittedTriangleBarycentrics();
    }

    return outHit;
}

static float TraceShadowInline(in RayDesc ray, in uint rayMask, in uint rayFlags)
{
    // Returns 1.0 if unoccluded, 0.0 if occluded (respecting alpha test unless forced opaque).
    RayQuery < RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES > q;
    q.TraceRayInline(Scene, rayFlags, rayMask, ray);

    while (q.Proceed())
    {
        if (q.CandidateType() == CANDIDATE_NON_OPAQUE_TRIANGLE)
        {
            const uint geo = q.CandidateGeometryIndex();
            const uint prim = q.CandidatePrimitiveIndex();
            const float2 bary = q.CandidateTriangleBarycentrics();

            if (PassAlphaTest_RQ(geo, prim, bary))
            {
                q.CommitNonOpaqueTriangleHit();
            }
        }
    }

    return (q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) ? 0.0f : 1.0f;
}

// -------------------------------------------------------------------------------------------------
// Miss shading moved from MissShader()
// -------------------------------------------------------------------------------------------------

static float3 EvaluateMissRadiance(in float3 rayDirWS, in uint pathLength)
{
    if (AppSettings.EnableWhiteFurnaceMode)
        return 1.0.xxx;

    TextureCube skyTexture = ResourceDescriptorHeap[RayTraceCB.SkyTextureIdx];
    float3 radiance = AppSettings.EnableSky ? skyTexture.SampleLevel(LinearSampler, rayDirWS, 0.0f).xyz : 0.0.xxx;

    // Sun disk only for primary (same as original MissShader)
    if (pathLength == 1)
    {
        float cosSunAngle = dot(rayDirWS, RayTraceCB.SunDirectionWS);
        if (cosSunAngle >= RayTraceCB.CosSunAngularRadius)
            radiance = RayTraceCB.SunRenderColor;
    }

    return radiance;
}

// -------------------------------------------------------------------------------------------------
// One-bounce surface shading: derived from original PathTrace() but WITHOUT tracing the next radiance
// -------------------------------------------------------------------------------------------------

struct NextBounce
{
    bool valid;
    float3 dirWS;
    float3 throughput;
    float roughness;
    bool isDiffuse;
};

static void ShadeSurfaceAndSampleNext(
    in MeshVertex hitSurface,
    in Material material,
    in float3 incomingRayOriginWS,
    in float3 incomingRayDirWS,
    in uint pixelIdx,
    inout uint sampleSetIdx,
    in uint pathLength,
    in bool inIsDiffuse,
    in float inClampRoughnessValue,
    out float3 outRadianceAdd, // emissive + direct
    out NextBounce outNext)
{
    outRadianceAdd = 0.0.xxx;
    outNext.valid = false;
    outNext.dirWS = 0.0.xxx;
    outNext.throughput = 0.0.xxx;
    outNext.roughness = 0.0f;
    outNext.isDiffuse = false;

    if ((!AppSettings.EnableDiffuse && !AppSettings.EnableSpecular) ||
       (!AppSettings.EnableDirect && !AppSettings.EnableIndirect))
        return;

    if (pathLength > 1 && !AppSettings.EnableIndirect)
        return;

    float3x3 tangentToWorld = float3x3(hitSurface.Tangent, hitSurface.Bitangent, hitSurface.Normal);

    const float3 positionWS = hitSurface.Position;

    float3 normalWS = hitSurface.Normal;
    if (AppSettings.EnableNormalMaps)
    {
        Texture2D normalMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Normal)];

        float3 normalTS;
        normalTS.xy = normalMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).xy * 2.0f - 1.0f;
        normalTS.z = sqrt(1.0f - saturate(normalTS.x * normalTS.x + normalTS.y * normalTS.y));
        normalWS = normalize(mul(normalTS, tangentToWorld));

        tangentToWorld._31_32_33 = normalWS;
    }

    float3 baseColor = 1.0f;
    if (AppSettings.EnableAlbedoMaps && !AppSettings.EnableWhiteFurnaceMode)
    {
        Texture2D albedoMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Albedo)];
        baseColor = albedoMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).xyz;
    }

    Texture2D metallicMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Metallic)];
    const float metallic = saturate((AppSettings.EnableWhiteFurnaceMode ? 1.0f : metallicMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).x) * AppSettings.MetallicScale);

    const bool enableDiffuse = (AppSettings.EnableDiffuse && metallic < 1.0f) || AppSettings.EnableWhiteFurnaceMode;
    const bool enableSpecular = (AppSettings.EnableSpecular && (AppSettings.EnableIndirectSpecular ? !(AppSettings.AvoidCausticPaths && inIsDiffuse) : (pathLength == 1)));

    if (enableDiffuse == false && enableSpecular == false)
        return;

    Texture2D roughnessMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Roughness)];
    const float sqrtRoughness = saturate((AppSettings.EnableWhiteFurnaceMode ? 1.0f : roughnessMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).x) * AppSettings.RoughnessScale);

    const float3 diffuseAlbedo = lerp(baseColor, 0.0f, metallic) * (enableDiffuse ? 1.0f : 0.0f);
    const float3 specularAlbedo = lerp(0.03f, baseColor, metallic) * (enableSpecular ? 1.0f : 0.0f);

    float roughness = sqrtRoughness * sqrtRoughness;
    if (AppSettings.ClampRoughness)
        roughness = max(roughness, inClampRoughnessValue);

    float3 msEnergyCompensation = 1.0.xxx;
    if (AppSettings.ApplyMultiscatteringEnergyCompensation)
    {
        float2 DFG = GGXEnvironmentBRDFScaleBias(saturate(dot(normalWS, -incomingRayDirWS)), sqrtRoughness);
        float Ess = DFG.x;
        msEnergyCompensation = 1.0.xxx + specularAlbedo * (1.0f / Ess - 1.0f);
    }

    Texture2D emissiveMap = ResourceDescriptorHeap[NonUniformResourceIndex(material.Emissive)];
    float3 radiance = AppSettings.EnableWhiteFurnaceMode ? 0.0.xxx : emissiveMap.SampleLevel(MeshSampler, hitSurface.UV, 0.0f).xyz;

    // ---------------- Direct lighting (Sun) ----------------
    if (AppSettings.EnableSun && !AppSettings.EnableWhiteFurnaceMode)
    {
        float3 sunDirection = RayTraceCB.SunDirectionWS;

        if (AppSettings.SunAreaLightApproximation)
        {
            float3 D = RayTraceCB.SunDirectionWS;
            float3 R = reflect(incomingRayDirWS, normalWS);
            float r = RayTraceCB.SinSunAngularRadius;
            float d = RayTraceCB.CosSunAngularRadius;
            float DDotR = dot(D, R);
            float3 S = R - DDotR * D;
            sunDirection = DDotR < d ? normalize(d * D + normalize(S) * r) : R;
        }

        RayDesc shadowRay;
        shadowRay.Origin = positionWS;
        shadowRay.Direction = RayTraceCB.SunDirectionWS;
        shadowRay.TMin = 0.00001f;
        shadowRay.TMax = FP32Max;

        uint shadowFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
        if (pathLength > AppSettings.MaxAnyHitPathLength)
            shadowFlags = RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;

        const float visibility = TraceShadowInline(shadowRay, 0xFFFFFFFF, shadowFlags);

        radiance += CalcLighting(normalWS, sunDirection, RayTraceCB.SunIrradiance, diffuseAlbedo, specularAlbedo,
                                 roughness, positionWS, incomingRayOriginWS, msEnergyCompensation) * visibility;
    }

    // ---------------- Direct lighting (Spot lights) ----------------
    if (AppSettings.RenderLights)
    {
        for (uint spotLightIdx = 0; spotLightIdx < RayTraceCB.NumLights; spotLightIdx++)
        {
            SpotLight spotLight = LightCBuffer.Lights[spotLightIdx];

            float3 surfaceToLight = spotLight.Position - positionWS;
            float distanceToLight = length(surfaceToLight);
            surfaceToLight /= distanceToLight;
            float angleFactor = saturate(dot(surfaceToLight, spotLight.Direction));
            float angularAttenuation = smoothstep(spotLight.AngularAttenuationY, spotLight.AngularAttenuationX, angleFactor);

            float d = distanceToLight / spotLight.Range;
            float falloff = saturate(1.0f - (d * d * d * d));
            falloff = (falloff * falloff) / (distanceToLight * distanceToLight + 1.0f);

            angularAttenuation *= falloff;

            if (angularAttenuation > 0.0f)
            {
                RayDesc shadowRay;
                shadowRay.Origin = positionWS + normalWS * 0.01f;
                shadowRay.Direction = surfaceToLight;
                shadowRay.TMin = SpotShadowNearClip;
                shadowRay.TMax = distanceToLight - SpotShadowNearClip;

                uint shadowFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
                if (pathLength > AppSettings.MaxAnyHitPathLength)
                    shadowFlags = RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;

                const float visibility = TraceShadowInline(shadowRay, 0xFFFFFFFF, shadowFlags);

                float3 intensity = spotLight.Intensity * angularAttenuation;

                radiance += CalcLighting(normalWS, surfaceToLight, intensity, diffuseAlbedo, specularAlbedo,
                                         roughness, positionWS, incomingRayOriginWS, msEnergyCompensation) * visibility;
            }
        }
    }

    // If primary and direct disabled -> match original PathTrace behavior
    if (pathLength == 1 && !AppSettings.EnableDirect)
        radiance = 0.0.xxx;

    // ---------------- Sample next bounce direction & throughput ----------------
    float2 brdfSample = SamplePoint(pixelIdx, sampleSetIdx);

    float3 throughput = 0.0.xxx;
    float3 rayDirTS = 0.0.xxx;

    float selector = brdfSample.x;
    if (enableSpecular == false)
        selector = 0.0f;
    else if (enableDiffuse == false)
        selector = 1.0f;

    bool nextIsDiffuse = false;

    if (selector < 0.5f)
    {
        if (enableSpecular)
            brdfSample.x *= 2.0f;

        rayDirTS = SampleDirectionCosineHemisphere(brdfSample.x, brdfSample.y);
        throughput = diffuseAlbedo;
        nextIsDiffuse = true;
    }
    else
    {
        if (enableDiffuse)
            brdfSample.x = (brdfSample.x - 0.5f) * 2.0f;

        float3 incomingRayDirTS = normalize(mul(incomingRayDirWS, transpose(tangentToWorld)));
        float3 microfacetNormalTS = SampleGGXVisibleNormal(-incomingRayDirTS, roughness, roughness, brdfSample.x, brdfSample.y);
        float3 sampleDirTS = reflect(incomingRayDirTS, microfacetNormalTS);

        float3 normalTS = float3(0.0f, 0.0f, 1.0f);

        float3 F = AppSettings.EnableWhiteFurnaceMode ? 1.0.xxx : Fresnel(specularAlbedo, microfacetNormalTS, sampleDirTS);
        float G1 = SmithGGXMasking(normalTS, sampleDirTS, -incomingRayDirTS, roughness * roughness);
        float G2 = SmithGGXMaskingShadowing(normalTS, sampleDirTS, -incomingRayDirTS, roughness * roughness);

        throughput = (F * (G2 / G1));
        rayDirTS = sampleDirTS;

        if (AppSettings.ApplyMultiscatteringEnergyCompensation)
        {
            float2 DFG = GGXEnvironmentBRDFScaleBias(saturate(dot(normalTS, -incomingRayDirWS)), sqrtRoughness);
            float Ess = DFG.x;
            throughput *= 1.0.xxx + specularAlbedo * (1.0f / Ess - 1.0f);
        }

        nextIsDiffuse = false;
    }

    const float3 rayDirWS = normalize(mul(rayDirTS, tangentToWorld));

    if (enableDiffuse && enableSpecular)
        throughput *= 2.0f;

    outRadianceAdd = radiance;

    outNext.valid = true;
    outNext.dirWS = rayDirWS;
    outNext.throughput = throughput;
    outNext.roughness = roughness;
    outNext.isDiffuse = nextIsDiffuse;
}

// -------------------------------------------------------------------------------------------------
// now does full path loop using RayQuery
// -------------------------------------------------------------------------------------------------
[numthreads(8, 8, 1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    int width;
    int height;
    RenderTarget.GetDimensions(width, height);
    const uint2 pixelCoord = dispatchThreadID.xy;
    const uint pixelIdx = pixelCoord.y * width + pixelCoord.x;

    uint sampleSetIdx = 0;

    // Primary ray (same as original)
    float2 primaryRaySample = SamplePoint(pixelIdx, sampleSetIdx);

    float2 rayPixelPos = pixelCoord + primaryRaySample;
    float2 ncdXY = (rayPixelPos / (float2(width, height) * 0.5f)) - 1.0f;
    ncdXY.y *= -1.0f;

    float4 rayStart = mul(float4(ncdXY, 0.0f, 1.0f), RayTraceCB.InvViewProjection);
    float4 rayEnd = mul(float4(ncdXY, 1.0f, 1.0f), RayTraceCB.InvViewProjection);

    rayStart.xyz /= rayStart.w;
    rayEnd.xyz /= rayEnd.w;

    float3 rayDir = normalize(rayEnd.xyz - rayStart.xyz);
    float rayLength = length(rayEnd.xyz - rayStart.xyz);

    RayDesc ray;
    ray.Origin = rayStart.xyz;
    ray.Direction = rayDir;
    ray.TMin = 0.0f;
    ray.TMax = rayLength;

    float3 radiance = 0.0.xxx;
    float3 pathThroughput = 1.0.xxx;

    uint pathLength = 1;
    bool isDiffuse = false;
    float clampRoughnessValue = 0.0f;

    // Path loop
    [loop]
    for (uint bounce = 0; bounce < AppSettings.MaxPathLength; ++bounce)
    {
        uint rayFlags = 0;

        // Stop doing alpha-test after a depth threshold (match original behavior)
        if (pathLength > AppSettings.MaxAnyHitPathLength)
            rayFlags |= RAY_FLAG_FORCE_OPAQUE;

        HitInfoRQ hit = TraceClosestHitInline_Radiance(ray, 0xFFFFFFFF, rayFlags);

        if (hit.hit == false)
        {
            radiance += pathThroughput * EvaluateMissRadiance(ray.Direction, pathLength);
            break;
        }

        // Reconstruct surface and material
        MeshVertex hitSurface = GetHitSurface_RQ(hit.bary, hit.geometryIdx, hit.primitiveIdx);
        Material material = GetGeometryMaterial_RQ(hit.geometryIdx);

        const float3 incomingRayOriginWS = ray.Origin;
        const float3 incomingRayDirWS = ray.Direction;

        float3 addRad;
        NextBounce next;
        ShadeSurfaceAndSampleNext(
            hitSurface, material,
            incomingRayOriginWS, incomingRayDirWS,
            pixelIdx, sampleSetIdx,
            pathLength,
            isDiffuse,
            clampRoughnessValue,
            addRad, next);

        radiance += pathThroughput * addRad;

        // If shading decided no next bounce, terminate
        if (next.valid == false)
            break;

        // If we are not allowed to continue indirect, or about to exceed max, do the original "visibility env" trick
        const bool canContinue =
            AppSettings.EnableIndirect &&
            ((pathLength + 1) < AppSettings.MaxPathLength) &&
            (!AppSettings.EnableWhiteFurnaceMode);

        if (!canContinue)
        {
            // Shoot a visibility ray along the sampled direction:
            RayDesc visRay;
            visRay.Origin = hitSurface.Position;
            visRay.Direction = next.dirWS;
            visRay.TMin = 0.00001f;
            visRay.TMax = FP32Max;

            uint visFlags = RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH;
            if ((pathLength + 1) > AppSettings.MaxAnyHitPathLength)
                visFlags |= RAY_FLAG_FORCE_OPAQUE;

            const float visibility = TraceShadowInline(visRay, 0xFFFFFFFF, visFlags);

            if (AppSettings.EnableWhiteFurnaceMode)
            {
                radiance += pathThroughput * next.throughput; // match original furnace termination
            }
            else
            {
                TextureCube skyTexture = TexCubeTable[RayTraceCB.SkyTextureIdx];
                float3 skyRadiance = AppSettings.EnableSky ? skyTexture.SampleLevel(LinearSampler, next.dirWS, 0.0f).xyz : 0.0.xxx;
                radiance += pathThroughput * (visibility * skyRadiance * next.throughput);
            }

            break;
        }

        // Continue to next bounce
        pathThroughput *= next.throughput;
        isDiffuse = next.isDiffuse;
        clampRoughnessValue = next.roughness;
        pathLength += 1;

        ray.Origin = hitSurface.Position;
        ray.Direction = next.dirWS;
        ray.TMin = 0.00001f;
        ray.TMax = FP32Max;
    }

    radiance = clamp(radiance, 0.0f, FP16Max);

    // Progressive accumulation (same as original)
    const float lerpFactor = RayTraceCB.CurrSampleIdx / (RayTraceCB.CurrSampleIdx + 1.0f);
    float3 newSample = radiance;
    float3 currValue = RenderTarget[pixelCoord].xyz;
    float3 newValue = lerp(newSample, currValue, lerpFactor);

    RenderTarget[pixelCoord] = float4(newValue, 1.0f);
}
